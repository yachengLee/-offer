查找指定值：
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        bool found=false;
        if(array.empty())
        {
            return false;
        }
        int rows = array.size();
        int cols = array[0].size();
        int row=0,col=cols-1;
        while(row<rows&&col>=0)
        {
            if(array[row][col]==target){
                found=true;
                break;
            }
            if(array[row][col]>target){
                col--;
            }
            else if(array[row][col]<target){
                row++;
            }
        }
        return found;
    }
};
查找第k小的值：最大最小堆
class Solution {  
public:  
    int kthSmallest(vector<vector<int> > &matrix, int k) {  
        // write your code here  
        int n = matrix.size();  
        int m = matrix[0].size();  
        priority_queue<pair<int,pair<int,int> >,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int>> >> q;  
        map<pair<int,int>,bool> visited;  
        q.push(make_pair(matrix[0][0],make_pair(0,0)));  
        visited[make_pair(0,0)]=true;  
        while(k--)  
        {  
            pair<int,pair<int,int> > cur = q.top();  
            if(k==0)  
                return cur.first;  
            q.pop();  
            if(cur.second.first+1<n&&visited[make_pair(cur.second.first+1,cur.second.second)]==false)  
            {  
                q.push(make_pair(matrix[cur.second.first+1][cur.second.second],make_pair(cur.second.first+1,cur.second.second)));  
                visited[make_pair(cur.second.first+1,cur.second.second)]=true;  
            }  
            if(cur.second.second+1<m&&visited[make_pair(cur.second.first,cur.second.second+1)]==false)  
            {  
                q.push(make_pair(matrix[cur.second.first][cur.second.second+1],make_pair(cur.second.first,cur.second.second+1)));  
                visited[make_pair(cur.second.first,cur.second.second+1)]=true;  
            }  
        }  
    }  
};  
二分法+堆
int find_kth_in_YoungTableau(int** a, int m, int n, int k) 
{   
    int low = a[0][0];   
    int high = a[m-1][n-1];   
    int order = 0;   
    int mid = 0;   
    do {     
        mid = (low + high) >> 1;     
        order = get_order(a, m, n, mid);     
        if(order == k)       
            break;     
        else if(order > k)       
            high = mid - 1;     
        else       
            low = mid + 1;   
    } while(1); //二分枚举整，找出正好大于k的一个整数 mid      
    int row = 0;   
    int col = n - 1;   
    int ret = mid;   
    while(row <= m-1 && col >= 0) 
    { //找出比mid小的最大数     
        if(a[row][col] < mid) {       
             ret = (a[row][col] > ret) ? a[row][col] : ret;      
             row++;     
        } else {       
            col--;     
        }   
    }   
    return ret; 
}   
int get_order(int** a, int m, int n, int k) 
{   
    int row, col, order;   
    row = 0;   col = n-1;   order = 0;   
    while(row <= m-1 && col >= 0) {     
        if(a[row][col] < k) {       
            order += col + 1;       
            row++;     
        }else {       
            col--;     
        }   
    }   
    return order; 
}
